// Apply command - Auto-fix guardrail violations
// Implemented by RedOwl

import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';
import { resolve, dirname } from 'path';
import { homedir } from 'os';
import type { FixOptions, FixResults, FixDetail } from '../core/types';
import { GuardrailsEngine } from '../core/engine';

// Shell ç±»å‹
type ShellType = 'bash' | 'zsh' | 'fish';

interface ShellAdapter {
  type: ShellType;
  configPath: string;
  aliasSyntax: (name: string, command: string) => string;
  commentSyntax: (text: string) => string;
}

const shellAdapters: Record<ShellType, ShellAdapter> = {
  bash: {
    type: 'bash',
    configPath: resolve(homedir(), '.bashrc'),
    aliasSyntax: (name, command) => `alias ${name}='${command}'`,
    commentSyntax: (text) => `# ${text}`
  },
  zsh: {
    type: 'zsh',
    configPath: resolve(homedir(), '.zshrc'),
    aliasSyntax: (name, command) => `alias ${name}='${command}'`,
    commentSyntax: (text) => `# ${text}`
  },
  fish: {
    type: 'fish',
    configPath: resolve(homedir(), '.config', 'fish', 'config.fish'),
    aliasSyntax: (name, command) => `abbr ${name} ${command}`,
    commentSyntax: (text) => `# ${text}`
  }
};

function detectShell(): ShellType {
  const shell = process.env.SHELL || '';
  if (shell.includes('zsh')) return 'zsh';
  if (shell.includes('bash')) return 'bash';
  if (shell.includes('fish')) return 'fish';
  return 'bash';
}

function getShellAdapter(): ShellAdapter {
  return shellAdapters[detectShell()];
}

function readFileSafe(path: string): string | null {
  try {
    return readFileSync(path, 'utf-8');
  } catch {
    return null;
  }
}

function createBackup(configPath: string): string {
  const backupDir = resolve(homedir(), '.guardrails', 'backups');
  mkdirSync(backupDir, { recursive: true });

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const configName = configPath.replace(/\//g, '_').replace(/^_/, '');
  const backupPath = resolve(backupDir, `${configName}_${timestamp}.backup`);

  const content = readFileSafe(configPath) || '';
  writeFileSync(backupPath, content, 'utf-8');

  // æ¸…ç†æ—§å¤‡ä»½ï¼Œåªä¿ç•™æœ€è¿‘ 5 ä¸ª
  cleanupOldBackups(backupDir, 5);

  return backupPath;
}

function cleanupOldBackups(backupDir: string, keepCount: number): void {
  try {
    const { readdirSync, statSync, unlinkSync } = require('fs');
    const files = readdirSync(backupDir)
      .map((f: string) => ({ name: f, path: resolve(backupDir, f), stat: statSync(resolve(backupDir, f)) }))
      .sort((a: any, b: any) => b.stat.mtime.getTime() - a.stat.mtime.getTime());

    for (let i = keepCount; i < files.length; i++) {
      unlinkSync(files[i].path);
    }
  } catch {
    // å¿½ç•¥æ¸…ç†é”™è¯¯
  }
}

function generateConfigSection(
  adapter: ShellAdapter,
  ruleId: string,
  version: string,
  aliases: Record<string, string>
): string {
  const lines: string[] = [
    '',
    adapter.commentSyntax(`=== Guardrails: ${ruleId} [v${version}] ===`),
    adapter.commentSyntax('Auto-generated by pi guardrails'),
    adapter.commentSyntax(`Updated: ${new Date().toISOString()}`),
    ''
  ];

  for (const [name, command] of Object.entries(aliases)) {
    lines.push(adapter.aliasSyntax(name, command));
  }

  lines.push('');
  lines.push(adapter.commentSyntax('='.repeat(36)));
  lines.push('');

  return lines.join('\n');
}

function updateGuardrailsSection(
  configPath: string,
  ruleId: string,
  newSection: string
): void {
  const content = readFileSafe(configPath) || '';
  
  const startMarker = new RegExp(`# === Guardrails: ${ruleId} \\[v[^\\]]+\\] ===`);
  const endMarker = /# =+$/m;
  
  let newContent: string;
  
  if (startMarker.test(content)) {
    // æ›¿æ¢ç°æœ‰é…ç½®æ®µ
    const lines = content.split('\n');
    const result: string[] = [];
    let inSection = false;
    
    for (const line of lines) {
      if (startMarker.test(line)) {
        inSection = true;
        continue;
      }
      if (inSection && endMarker.test(line)) {
        inSection = false;
        continue;
      }
      if (!inSection) {
        result.push(line);
      }
    }
    
    newContent = result.join('\n') + newSection;
  } else {
    // è¿½åŠ æ–°é…ç½®æ®µ
    newContent = content + newSection;
  }
  
  writeFileSync(configPath, newContent, 'utf-8');
}

// è§„åˆ™ä¿®å¤æ˜ å°„
const ruleFixes: Record<string, (adapter: ShellAdapter, dryRun: boolean) => FixDetail> = {
  'safe-rm-intercept': (adapter, dryRun) => {
    const aliases = {
      'rm': 'trash',
      'rmrf': 'echo "Use trash instead of rm -rf" && trash',
      'trash-list': 'ls -la ~/.trash/',
      'trash-restore': 'mv ~/.trash/$1 ./'
    };
    
    const section = generateConfigSection(adapter, 'safe-rm', '1.0.0', aliases);
    
    if (!dryRun) {
      const backupPath = createBackup(adapter.configPath);
      updateGuardrailsSection(adapter.configPath, 'safe-rm', section);
      return {
        rule: 'safe-rm-intercept',
        original: 'rm (unsafe)',
        replacement: 'rm -> trash',
        status: 'applied',
        error: undefined
      };
    }
    
    return {
      rule: 'safe-rm-intercept',
      original: 'rm (unsafe)',
      replacement: 'rm -> trash',
      status: 'skipped'
    };
  },
  
  'safe-git-restore-dot': (adapter, dryRun) => {
    // è¿™æ˜¯ä¸€ä¸ªè­¦å‘Šç±»è§„åˆ™ï¼Œä¸»è¦å»ºè®®ç”¨æˆ·æ”¹ä¸ºå…·ä½“æ–‡ä»¶
    return {
      rule: 'safe-git-restore-dot',
      original: 'git restore .',
      replacement: 'git restore <specific-file>',
      status: dryRun ? 'skipped' : 'skipped',
      error: 'Requires manual intervention - use specific file paths'
    };
  },
  
  'tool-matrix-grep': (adapter, dryRun) => {
    const aliases = {
      'grep': 'echo "Consider using rg instead" && grep'
    };
    
    const section = generateConfigSection(adapter, 'tool-matrix', '1.0.0', aliases);
    
    if (!dryRun) {
      const backupPath = createBackup(adapter.configPath);
      updateGuardrailsSection(adapter.configPath, 'tool-matrix', section);
      return {
        rule: 'tool-matrix-grep',
        original: 'grep',
        replacement: 'rg (ripgrep)',
        status: 'applied'
      };
    }
    
    return {
      rule: 'tool-matrix-grep',
      original: 'grep',
      replacement: 'rg (ripgrep)',
      status: 'skipped'
    };
  }
};

export async function applyFixes(options: FixOptions = {}): Promise<FixResults> {
  console.log('ğŸ”§ Applying fixes...\n');
  
  if (options.dryRun) {
    console.log('  (Dry run mode - no changes will be made)\n');
  }
  
  const adapter = getShellAdapter();
  console.log(`  Shell: ${adapter.type}`);
  console.log(`  Config: ${adapter.configPath}\n`);
  
  const results: FixDetail[] = [];
  let applied = 0;
  let skipped = 0;
  let failed = 0;
  
  // è·å–æ‰€æœ‰å¯ä¿®å¤çš„è§„åˆ™
  const fixableRules = options.rule 
    ? [options.rule]
    : Object.keys(ruleFixes);
  
  for (const ruleId of fixableRules) {
    const fixFn = ruleFixes[ruleId];
    if (!fixFn) {
      console.log(`  â­ï¸  ${ruleId}: No auto-fix available`);
      skipped++;
      continue;
    }
    
    console.log(`  Fixing: ${ruleId}...`);
    
    try {
      const detail = fixFn(adapter, options.dryRun || false);
      results.push(detail);
      
      if (detail.status === 'applied') {
        applied++;
        console.log(`    âœ… Applied`);
      } else if (detail.status === 'skipped') {
        skipped++;
        console.log(`    â­ï¸  ${options.dryRun ? 'Would apply (dry run)' : (detail.error || 'Skipped')}`);
      } else {
        failed++;
        console.log(`    âŒ Failed: ${detail.error}`);
      }
    } catch (error) {
      failed++;
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.log(`    âŒ Error: ${errorMsg}`);
      results.push({
        rule: ruleId,
        original: '',
        replacement: '',
        status: 'failed',
        error: errorMsg
      });
    }
  }
  
  return {
    applied,
    skipped,
    failed,
    details: results
  };
}

export function printFixResults(results: FixResults): void {
  console.log('\n' + 'â”'.repeat(50));
  console.log('ğŸ“Š Fix Results:');
  console.log(`  âœ… Applied: ${results.applied}`);
  console.log(`  â­ï¸  Skipped: ${results.skipped}`);
  console.log(`  âŒ Failed: ${results.failed}`);
  console.log('â”'.repeat(50));
  
  if (results.applied > 0) {
    console.log('\nâš ï¸  Important:');
    console.log('   Configuration updated but not active in current session.');
    console.log('   Run: source ' + getShellAdapter().configPath);
    console.log('   Or: Restart your terminal');
  }
}
